---
import { BLOG_SLUG } from '@/consts'
import BlogPostLayout from '../../layouts/BlogPostLayout.astro'

import BlogPostsLayout from '@/layouts/BlogPostsLayout.astro'
import { getSortedPosts, type PostWithHero } from '@/lib/astro/post'
import { getPostSectionMap } from '@/lib/astro/sections'
import { getUrlFriendlyTag } from '@/lib/http/urls'
import { paginate, type AstroPage, type PageType } from '@/lib/paginate'
import { getPostSlugs } from '@/lib/post'
import { produce } from 'immer'

// interface Props extends IPaginationProps<CollectionEntry<'blog'>> {
//   title: string
//   root: string
// }

export async function getStaticPaths() {
  let posts = await getSortedPosts()

  let paths: AstroPage<PostWithHero>[] = []

  // create a page for every post
  for (const post of posts) {
    // If the post has sections, create a path for each section
    // flatten slug to the last part of the path
    // e.g. /test/my-post/ becomes /my-post/
    // this is useful for SEO and readability

    // url friendly last part of the id
    const slugs = getPostSlugs(post)

    for (const slug of slugs) {
      // we decouple the file storage structure from the URL structure
      // by flattening the slug to only use the last part of the path
      // and combining it with the section

      // path for a post is the flattened slug without sections
      paths.push({
        params: { slug },
        props: {
          type: 'post',
          title: post.data.title,
          root: '',
          page: 0,
          pages: 1,
          data: [post],
        },
      })
    }
  }

  const sectionMap = getPostSectionMap(posts)

  for (const [section, posts] of sectionMap.entries()) {
    const featuredPosts = posts.filter(post => post.data.featured)
    const otherPosts = posts.filter(post => !post.data.featured)

    const sectionParts = section.split('/').map(part => part.trim())
    const title = sectionParts.pop()!
    const slug = getUrlFriendlyTag(section)
    const root = `${BLOG_SLUG}/${slug}`

    const pages = paginate(otherPosts, { slug, title }).map(p =>
      produce(p, draft => {
        draft.props.root = root
        draft.props.featuredPosts = p.props.page === 0 ? featuredPosts : []
      })
    )

    paths = paths.concat(pages)
  }

  return paths
}

interface Props {
  type: PageType
  title?: string
  root?: string
  page: number
  pages: number
  data: PostWithHero[]
  featuredPosts?: PostWithHero[]
}

const { type, title, root, page, pages, data, featuredPosts } = Astro.props
---

<!-- Render a single post -->{
  type === 'post' && data.length > 0 && <BlogPostLayout post={data[0]} />
}

<!-- Render a page containing a list of posts -->
{
  type === 'posts' && (
    <BlogPostsLayout
      title={title!}
      page={page}
      pages={pages}
      posts={data}
      featuredPosts={featuredPosts}
      root={root!}
      showSectionLinks={root === BLOG_SLUG}
      showTitle={root !== BLOG_SLUG}
    />
  )
}
