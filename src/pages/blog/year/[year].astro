---
import ContentLayout from '@/layouts/ContentLayout.astro'

import FormattedDate from '@components/FormattedDate.astro'

import { getCollection } from 'astro:content'

// 1. Generate all unique tags for static paths
export async function getStaticPaths() {
  const posts = await getCollection('blog')
  //const baseDir = path.resolve('src/content/blog')

  // const postsWithLastModified = posts.map(post => {
  //   const filePath = findFileById(baseDir, post.id)
  //   if (!filePath) {
  //     throw new Error(`File not found for post id: ${post.id}`)
  //   }

  //   const stats = fs.statSync(filePath)
  //   return {
  //     ...post,
  //     lastModified: stats.mtime, // or .mtime.toISOString()
  //   }
  // })

  // params need to be strings so we convert the year to a string
  // and use a Set to ensure uniqueness
  const yearSet = new Set<string>()
  for (const post of posts) {
    yearSet.add(post.data.added.getFullYear().toString())

    if (post.data.updated) {
      // if the post has an updated date, add that year as well
      // to ensure we include posts that were updated in a different year
      // than they were added
      yearSet.add(post.data.updated.getFullYear().toString())
    }
  }

  return [...yearSet].map(year => ({
    params: { year },
  }))
}

// 2. Get the current tag param from the URL
const year = Number(Astro.params.year)

//const baseDir = path.resolve('src/content/blog')
const posts = await getCollection('blog')

// a little inefficient but ensures we get the last modified date
// for each post based on its file system last modified time
// but since it is a static site, this only affects the build time
// and not runtime performance
// const postsWithLastModified = posts.map(post => {
//   const filePath = findFileById(baseDir, post.id)
//   if (!filePath) {
//     throw new Error(`File not found for post id: ${post.id}`)
//   }

//   const stats = fs.statSync(filePath)
//   return {
//     ...post,
//     lastModified: stats.mtime, // or .mtime.toISOString()
//   }
// })

// 3. Filter posts that include the current tag (case-insensitive)
const filteredPosts = posts
  .filter(
    post =>
      post.data.added.getFullYear() === year ||
      post.data.updated?.getFullYear() === year
  )
  .sort((a, b) => {
    return b.data.added.getTime() - a.data.added.getTime()
  })
---

<ContentLayout
  title={`Posts written in ${year}`}
  description={`A collection of posts written in ${year}.`}
>
  <main slot="main">
    <h1>Posts written in {year}</h1>

    {
      filteredPosts.length === 0 ? (
        <p>No posts found for this year.</p>
      ) : (
        <ul>
          {filteredPosts.map(post => (
            <li>
              <a href={`/blog/${post.id}`}>{post.data.title}</a>
              <br />
              <small>
                <FormattedDate date={post.data.added} />
              </small>
            </li>
          ))}
        </ul>
      )
    }
  </main>
</ContentLayout>
